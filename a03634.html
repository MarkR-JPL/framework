<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReFRACtor: FullPhysics::NLLSProblem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReFRACtor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a03634.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a03631.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FullPhysics::NLLSProblem Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The base class for the Non-Linear Least Squares problem.  
 <a href="a03634.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a01064_source.html">nlls_problem.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for FullPhysics::NLLSProblem:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a03633.png" border="0" usemap="#_full_physics_1_1_n_l_l_s_problem_inherit__map" alt="Inheritance graph"/></div>
<map name="_full_physics_1_1_n_l_l_s_problem_inherit__map" id="_full_physics_1_1_n_l_l_s_problem_inherit__map">
<area shape="rect" id="node7" href="a02566.html" title="{FullPhysics::BardNLLSProblem\n||+ BardNLLSProblem()\l+ ~BardNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="5,1542,212,1707"/>
<area shape="rect" id="node8" href="a02570.html" title="{FullPhysics::BrownNLLSProblem\n||+ BrownNLLSProblem()\l+ ~BrownNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="237,1542,453,1707"/>
<area shape="rect" id="node9" href="a02670.html" title="This is the forward model cost function, rewritten to match the standard format used in nonlinear lea..." alt="" coords="477,1542,676,1707"/>
<area shape="rect" id="node10" href="a02678.html" title="{FullPhysics::Freudenstein\lRothNLLSProblem\n||+ FreudensteinRothNLLSProblem()\l+ ~FreudensteinRothNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="699,1535,934,1715"/>
<area shape="rect" id="node11" href="a02718.html" title="{FullPhysics::HelicalValley\lNLLSProblem\n||+ HelicalValleyNLLSProblem()\l+ ~HelicalValleyNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="959,1535,1165,1715"/>
<area shape="rect" id="node12" href="a02746.html" title="{FullPhysics::JennrichSampson\lNLLSProblem\n||+ JennrichSampsonNLLSProblem()\l+ ~JennrichSampsonNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="1190,1535,1425,1715"/>
<area shape="rect" id="node13" href="a03242.html" title="{FullPhysics::MeyerNLLSProblem\n||+ MeyerNLLSProblem()\l+ ~MeyerNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="1449,1542,1664,1707"/>
<area shape="rect" id="node14" href="a03258.html" title="{FullPhysics::NLLSMaxAPosteriori\n|# MAP\l|+ NLLSMaxAPosteriori()\l+ ~NLLSMaxAPosteriori()\l+ expected_parameter_size()\l+ jacobian()\l+ max_a_posteriori()\l+ parameters()\l+ parameters()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="1688,1520,1908,1729"/>
<area shape="rect" id="node15" href="a03262.html" title="{FullPhysics::NLLSMaxLikelihood\n|# ML\l|+ NLLSMaxLikelihood()\l+ ~NLLSMaxLikelihood()\l+ expected_parameter_size()\l+ jacobian()\l+ max_likelihood()\l+ parameters()\l+ parameters()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="1932,1520,2147,1729"/>
<area shape="rect" id="node16" href="a03266.html" title="{FullPhysics::NLLSProblem\lScaled\n|# P\l# S\l|+ NLLSProblemScaled()\l+ ~NLLSProblemScaled()\l+ expected_parameter_size()\l+ jacobian()\l+ nlls_problem()\l+ parameters()\l+ parameters()\l+ print()\l+ residual()\l+ residual_size()\l+ scale_parameters()\l+ unscale_parameters()\l}" alt="" coords="2171,1491,2361,1759"/>
<area shape="rect" id="node17" href="a03310.html" title="{FullPhysics::PowellNLLSProblem\n||+ PowellNLLSProblem()\l+ ~PowellNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="2386,1542,2605,1707"/>
<area shape="rect" id="node18" href="a03314.html" title="{FullPhysics::PowellSingular\lNLLSProblem\n||+ PowellSingularNLLSProblem()\l+ ~PowellSingularNLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="2629,1535,2847,1715"/>
<area shape="rect" id="node19" href="a03362.html" title="{FullPhysics::Rosenbrock2\lNLLSProblem\n||+ Rosenbrock2NLLSProblem()\l+ ~Rosenbrock2NLLSProblem()\l+ expected_parameter_size()\l+ jacobian()\l+ print()\l+ residual()\l+ residual_size()\l}" alt="" coords="2871,1535,3079,1715"/>
<area shape="rect" id="node2" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. " alt="" coords="1459,873,1655,1127"/>
<area shape="rect" id="node3" href="a03530.html" title="The base class for all problem classes that implement a cost function. " alt="" coords="1459,587,1655,825"/>
<area shape="rect" id="node4" href="a03686.html" title="The base class for all problem states. " alt="" coords="1461,271,1652,539"/>
<area shape="rect" id="node5" href="a04618.html" title="{FullPhysics::Printable\l\&lt; ProblemState \&gt;\n||+ print_to_string()\l}" alt="" coords="1482,131,1631,223"/>
<area shape="rect" id="node6" href="a04498.html" title="For use with SWIG, it is useful to have a base class that everything can be cast to. " alt="" coords="1466,5,1647,83"/>
</map>
</div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for FullPhysics::NLLSProblem:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a03632.png" border="0" usemap="#_full_physics_1_1_n_l_l_s_problem_coll__map" alt="Collaboration graph"/></div>
<map name="_full_physics_1_1_n_l_l_s_problem_coll__map" id="_full_physics_1_1_n_l_l_s_problem_coll__map">
<area shape="rect" id="node2" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. " alt="" coords="5,873,201,1127"/>
<area shape="rect" id="node3" href="a03530.html" title="The base class for all problem classes that implement a cost function. " alt="" coords="5,587,201,825"/>
<area shape="rect" id="node4" href="a03686.html" title="The base class for all problem states. " alt="" coords="8,271,199,539"/>
<area shape="rect" id="node5" href="a04618.html" title="{FullPhysics::Printable\l\&lt; ProblemState \&gt;\n||+ print_to_string()\l}" alt="" coords="29,131,178,223"/>
<area shape="rect" id="node6" href="a04498.html" title="For use with SWIG, it is useful to have a base class that everything can be cast to. " alt="" coords="13,5,194,83"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a944f714d9dae40883d7783dec09b4b16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16">message_t</a> { <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a80496e9b6583c77605699a042ecdc456">NONE</a>, 
<a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a63f660718f812ce207a64a8c28706dd6">SOLVED</a>, 
<a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a09ab40e78a0d87e3ab77dd9d04a16603">ERROR</a>
 }<tr class="memdesc:a944f714d9dae40883d7783dec09b4b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum type for the message generated by the problem.  <a href="a03530.html#a944f714d9dae40883d7783dec09b4b16">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a944f714d9dae40883d7783dec09b4b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8570597ca3e0c48d2736f60d90d53e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#ad8570597ca3e0c48d2736f60d90d53e6">NLLSProblem</a> ()</td></tr>
<tr class="memdesc:ad8570597ca3e0c48d2736f60d90d53e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#ad8570597ca3e0c48d2736f60d90d53e6">More...</a><br /></td></tr>
<tr class="separator:ad8570597ca3e0c48d2736f60d90d53e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71b502f0a0d38915c8933770c185b4e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#ae71b502f0a0d38915c8933770c185b4e">~NLLSProblem</a> ()</td></tr>
<tr class="separator:ae71b502f0a0d38915c8933770c185b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d88c6f0c515fc412531a3cd7d5f6c13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#a9d88c6f0c515fc412531a3cd7d5f6c13">assert_parameter_correct</a> (const blitz::Array&lt; double, 1 &gt; &amp;x) const</td></tr>
<tr class="memdesc:a9d88c6f0c515fc412531a3cd7d5f6c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the new input parameters are correct.  <a href="#a9d88c6f0c515fc412531a3cd7d5f6c13">More...</a><br /></td></tr>
<tr class="separator:a9d88c6f0c515fc412531a3cd7d5f6c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a74617bd73494e1713468a70b0cd0a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#a8a74617bd73494e1713468a70b0cd0a8">assert_parameter_set_correctly</a> () const</td></tr>
<tr class="memdesc:a8a74617bd73494e1713468a70b0cd0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the parameters are set correctly.  <a href="#a8a74617bd73494e1713468a70b0cd0a8">More...</a><br /></td></tr>
<tr class="separator:a8a74617bd73494e1713468a70b0cd0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a34d7aec9c7fdf5975c193a0ea5b24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#a82a34d7aec9c7fdf5975c193a0ea5b24">clear</a> ()</td></tr>
<tr class="memdesc:a82a34d7aec9c7fdf5975c193a0ea5b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes data contents.  <a href="#a82a34d7aec9c7fdf5975c193a0ea5b24">More...</a><br /></td></tr>
<tr class="separator:a82a34d7aec9c7fdf5975c193a0ea5b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f92a8a1f649b2a72237bc8514d1208"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#a62f92a8a1f649b2a72237bc8514d1208">cost</a> ()</td></tr>
<tr class="memdesc:a62f92a8a1f649b2a72237bc8514d1208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read comments on <a class="el" href="a03530.html#a59b277278849ad14484394188379c2bd" title="The cost function. ">CostFunc::cost()</a>  <a href="#a62f92a8a1f649b2a72237bc8514d1208">More...</a><br /></td></tr>
<tr class="separator:a62f92a8a1f649b2a72237bc8514d1208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fdea8919e6f537f6df3f8d0319cfbd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#ab3fdea8919e6f537f6df3f8d0319cfbd">cost_gradient</a> (double &amp;c, blitz::Array&lt; double, 1 &gt; &amp;g)</td></tr>
<tr class="memdesc:ab3fdea8919e6f537f6df3f8d0319cfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost function and its gradient together.  <a href="#ab3fdea8919e6f537f6df3f8d0319cfbd">More...</a><br /></td></tr>
<tr class="separator:ab3fdea8919e6f537f6df3f8d0319cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab978fff25f8b7707dc76cf8338306cb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#ab978fff25f8b7707dc76cf8338306cb9">cost_gradient_x</a> (const blitz::Array&lt; double, 1 &gt; &amp;x, double &amp;c, blitz::Array&lt; double, 1 &gt; &amp;g)</td></tr>
<tr class="memdesc:ab978fff25f8b7707dc76cf8338306cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost function and its gradient with parameters.  <a href="#ab978fff25f8b7707dc76cf8338306cb9">More...</a><br /></td></tr>
<tr class="separator:ab978fff25f8b7707dc76cf8338306cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c0c2f1c7b79f770d9a9348c56a29c6"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#a24c0c2f1c7b79f770d9a9348c56a29c6">cost_x</a> (const blitz::Array&lt; double, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a24c0c2f1c7b79f770d9a9348c56a29c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost function with parameters.  <a href="#a24c0c2f1c7b79f770d9a9348c56a29c6">More...</a><br /></td></tr>
<tr class="separator:a24c0c2f1c7b79f770d9a9348c56a29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc11f14bee4751e1a2c34ecaa70894af"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#adc11f14bee4751e1a2c34ecaa70894af">expected_parameter_size</a> () const</td></tr>
<tr class="memdesc:adc11f14bee4751e1a2c34ecaa70894af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expected size of the parameters.  <a href="#adc11f14bee4751e1a2c34ecaa70894af">More...</a><br /></td></tr>
<tr class="separator:adc11f14bee4751e1a2c34ecaa70894af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d68693bbbe2ee31fb93fde8638c0c6"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#a89d68693bbbe2ee31fb93fde8638c0c6">gradient</a> ()</td></tr>
<tr class="memdesc:a89d68693bbbe2ee31fb93fde8638c0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read comments on <a class="el" href="a03534.html#a76dd357c7aa315487b5a7d52000b481e" title="The gradient of the cost function. ">CostFuncDiff::gradient()</a>  <a href="#a89d68693bbbe2ee31fb93fde8638c0c6">More...</a><br /></td></tr>
<tr class="separator:a89d68693bbbe2ee31fb93fde8638c0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e3ba335fe38770e1a00841167466fc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#a65e3ba335fe38770e1a00841167466fc">gradient_size</a> () const</td></tr>
<tr class="memdesc:a65e3ba335fe38770e1a00841167466fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the gradient vector.  <a href="#a65e3ba335fe38770e1a00841167466fc">More...</a><br /></td></tr>
<tr class="separator:a65e3ba335fe38770e1a00841167466fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916f7963b036e3a3113bc0d8e412b2e0"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#a916f7963b036e3a3113bc0d8e412b2e0">gradient_x</a> (const blitz::Array&lt; double, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a916f7963b036e3a3113bc0d8e412b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gradient function with parameters.  <a href="#a916f7963b036e3a3113bc0d8e412b2e0">More...</a><br /></td></tr>
<tr class="separator:a916f7963b036e3a3113bc0d8e412b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aea615310738b4878e046d70a41881"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#ac3aea615310738b4878e046d70a41881">jacobian</a> ()=0</td></tr>
<tr class="memdesc:ac3aea615310738b4878e046d70a41881"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Jacobian matrix function.  <a href="#ac3aea615310738b4878e046d70a41881">More...</a><br /></td></tr>
<tr class="separator:ac3aea615310738b4878e046d70a41881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ed15ffb9ed8263ba145423a060aa09"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#af6ed15ffb9ed8263ba145423a060aa09">jacobian_x</a> (const blitz::Array&lt; double, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:af6ed15ffb9ed8263ba145423a060aa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Jacobian function with parameters.  <a href="#af6ed15ffb9ed8263ba145423a060aa09">More...</a><br /></td></tr>
<tr class="separator:af6ed15ffb9ed8263ba145423a060aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ee6a711398e496f227e73e16661717"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16">message_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#a36ee6a711398e496f227e73e16661717">message</a> () const</td></tr>
<tr class="memdesc:a36ee6a711398e496f227e73e16661717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value of <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16" title="Enum type for the message generated by the problem. ">CostFunc::message_t</a> type.  <a href="#a36ee6a711398e496f227e73e16661717">More...</a><br /></td></tr>
<tr class="separator:a36ee6a711398e496f227e73e16661717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cabd454ac6952b51d179c1465cc45ac"><td class="memItemLeft" align="right" valign="top">virtual const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#a8cabd454ac6952b51d179c1465cc45ac">message_str</a> () const</td></tr>
<tr class="memdesc:a8cabd454ac6952b51d179c1465cc45ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string version of the problem message.  <a href="#a8cabd454ac6952b51d179c1465cc45ac">More...</a><br /></td></tr>
<tr class="separator:a8cabd454ac6952b51d179c1465cc45ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf7aaf54949298bd97d395ebe91faa2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#a8bf7aaf54949298bd97d395ebe91faa2">num_cost_evaluations</a> () const</td></tr>
<tr class="memdesc:a8bf7aaf54949298bd97d395ebe91faa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the times cost has been evaluated.  <a href="#a8bf7aaf54949298bd97d395ebe91faa2">More...</a><br /></td></tr>
<tr class="separator:a8bf7aaf54949298bd97d395ebe91faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa394e8c65adbaa539df24ff867992abd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#aa394e8c65adbaa539df24ff867992abd">num_der1_evaluations</a> () const</td></tr>
<tr class="memdesc:aa394e8c65adbaa539df24ff867992abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the times gradient has been evaluated.  <a href="#aa394e8c65adbaa539df24ff867992abd">More...</a><br /></td></tr>
<tr class="separator:aa394e8c65adbaa539df24ff867992abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd672c7a966b6f6797ad9b5c00c3080"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#a0fd672c7a966b6f6797ad9b5c00c3080">num_jacobian_evaluations</a> () const</td></tr>
<tr class="memdesc:a0fd672c7a966b6f6797ad9b5c00c3080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the times Jacobian has been evaluated.  <a href="#a0fd672c7a966b6f6797ad9b5c00c3080">More...</a><br /></td></tr>
<tr class="separator:a0fd672c7a966b6f6797ad9b5c00c3080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e1926e49bb96d4f9cd23a4f0d35b4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#aa23e1926e49bb96d4f9cd23a4f0d35b4">num_residual_evaluations</a> () const</td></tr>
<tr class="memdesc:aa23e1926e49bb96d4f9cd23a4f0d35b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the times residual has been evaluated.  <a href="#aa23e1926e49bb96d4f9cd23a4f0d35b4">More...</a><br /></td></tr>
<tr class="separator:aa23e1926e49bb96d4f9cd23a4f0d35b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb80491a2ba69cb450ddc122730d96f2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#afb80491a2ba69cb450ddc122730d96f2">parameter_size</a> () const</td></tr>
<tr class="memdesc:afb80491a2ba69cb450ddc122730d96f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the parameters.  <a href="#afb80491a2ba69cb450ddc122730d96f2">More...</a><br /></td></tr>
<tr class="separator:afb80491a2ba69cb450ddc122730d96f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5427cd26e12e24d4b69778243363e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#aef5427cd26e12e24d4b69778243363e8">parameters</a> (const blitz::Array&lt; double, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:aef5427cd26e12e24d4b69778243363e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the problem at a new point in the parameter space.  <a href="#aef5427cd26e12e24d4b69778243363e8">More...</a><br /></td></tr>
<tr class="separator:aef5427cd26e12e24d4b69778243363e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eb5f3b2856a3be0d0ce5416063c83b"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#ac6eb5f3b2856a3be0d0ce5416063c83b">parameters</a> () const</td></tr>
<tr class="memdesc:ac6eb5f3b2856a3be0d0ce5416063c83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current parameters.  <a href="#ac6eb5f3b2856a3be0d0ce5416063c83b">More...</a><br /></td></tr>
<tr class="separator:ac6eb5f3b2856a3be0d0ce5416063c83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13a0649637d0510602e9eb0abffca9a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#ab13a0649637d0510602e9eb0abffca9a">parameters_different</a> (const blitz::Array&lt; double, 1 &gt; &amp;x) const</td></tr>
<tr class="memdesc:ab13a0649637d0510602e9eb0abffca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether or not new input parameters are different from the current ones.  <a href="#ab13a0649637d0510602e9eb0abffca9a">More...</a><br /></td></tr>
<tr class="separator:ab13a0649637d0510602e9eb0abffca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecc6162b90ea155dffe1250d6413afb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#a8ecc6162b90ea155dffe1250d6413afb">print</a> (std::ostream &amp;Os) const</td></tr>
<tr class="memdesc:a8ecc6162b90ea155dffe1250d6413afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints description of object.  <a href="#a8ecc6162b90ea155dffe1250d6413afb">More...</a><br /></td></tr>
<tr class="separator:a8ecc6162b90ea155dffe1250d6413afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa21f558fa22a1f06175a1357c7f5a22"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04618.html#aaa21f558fa22a1f06175a1357c7f5a22">print_to_string</a> () const</td></tr>
<tr class="memdesc:aaa21f558fa22a1f06175a1357c7f5a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to string.  <a href="#aaa21f558fa22a1f06175a1357c7f5a22">More...</a><br /></td></tr>
<tr class="separator:aaa21f558fa22a1f06175a1357c7f5a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e584291e1337af17fcf9b22792ccc6"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#a34e584291e1337af17fcf9b22792ccc6">residual</a> ()=0</td></tr>
<tr class="memdesc:a34e584291e1337af17fcf9b22792ccc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The residual vector function.  <a href="#a34e584291e1337af17fcf9b22792ccc6">More...</a><br /></td></tr>
<tr class="separator:a34e584291e1337af17fcf9b22792ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32ac2df20983d61228eeae47380e6e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#ad32ac2df20983d61228eeae47380e6e6">residual_jacobian</a> (blitz::Array&lt; double, 1 &gt; &amp;r, blitz::Array&lt; double, 2 &gt; &amp;j)</td></tr>
<tr class="memdesc:ad32ac2df20983d61228eeae47380e6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The residual function and its Jacobian together.  <a href="#ad32ac2df20983d61228eeae47380e6e6">More...</a><br /></td></tr>
<tr class="separator:ad32ac2df20983d61228eeae47380e6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af197676bde1e1f65756d2649177ee1f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#af197676bde1e1f65756d2649177ee1f2">residual_jacobian_x</a> (const blitz::Array&lt; double, 1 &gt; &amp;x, blitz::Array&lt; double, 1 &gt; &amp;r, blitz::Array&lt; double, 2 &gt; &amp;j)</td></tr>
<tr class="memdesc:af197676bde1e1f65756d2649177ee1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The residual and its Jacobian with parameters.  <a href="#af197676bde1e1f65756d2649177ee1f2">More...</a><br /></td></tr>
<tr class="separator:af197676bde1e1f65756d2649177ee1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ef1fc7d9345085e7898dc6f5277fbb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#a07ef1fc7d9345085e7898dc6f5277fbb">residual_size</a> () const =0</td></tr>
<tr class="memdesc:a07ef1fc7d9345085e7898dc6f5277fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the residual returned by <a class="el" href="a03634.html#a34e584291e1337af17fcf9b22792ccc6" title="The residual vector function. ">residual()</a>  <a href="#a07ef1fc7d9345085e7898dc6f5277fbb">More...</a><br /></td></tr>
<tr class="separator:a07ef1fc7d9345085e7898dc6f5277fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dc6f23d523caf9573f5e72bd377c85"><td class="memItemLeft" align="right" valign="top">virtual blitz::Array&lt; double, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03634.html#ab4dc6f23d523caf9573f5e72bd377c85">residual_x</a> (const blitz::Array&lt; double, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:ab4dc6f23d523caf9573f5e72bd377c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The residual function with parameters.  <a href="#ab4dc6f23d523caf9573f5e72bd377c85">More...</a><br /></td></tr>
<tr class="separator:ab4dc6f23d523caf9573f5e72bd377c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344962852814f6b7610aac73b1a61ff4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#a344962852814f6b7610aac73b1a61ff4">set</a> (const <a class="el" href="a03686.html">ProblemState</a> &amp;s)</td></tr>
<tr class="memdesc:a344962852814f6b7610aac73b1a61ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes self a copy of the input state.  <a href="#a344962852814f6b7610aac73b1a61ff4">More...</a><br /></td></tr>
<tr class="separator:a344962852814f6b7610aac73b1a61ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bc58ea76aef6b4fd1bdc3212ac6cb7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#ac9bc58ea76aef6b4fd1bdc3212ac6cb7">zero_num_evaluations</a> ()</td></tr>
<tr class="memdesc:ac9bc58ea76aef6b4fd1bdc3212ac6cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets cost and gradient evaluation counters to zero.  <a href="#ac9bc58ea76aef6b4fd1bdc3212ac6cb7">More...</a><br /></td></tr>
<tr class="separator:ac9bc58ea76aef6b4fd1bdc3212ac6cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac40e427ca8e29afb50489ac25d31f6a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#ac40e427ca8e29afb50489ac25d31f6a3">increment_num_cost_evaluations</a> ()</td></tr>
<tr class="memdesc:ac40e427ca8e29afb50489ac25d31f6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments (by 1) cost evaluation counter.  <a href="#ac40e427ca8e29afb50489ac25d31f6a3">More...</a><br /></td></tr>
<tr class="separator:ac40e427ca8e29afb50489ac25d31f6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39197b7111b245ab8dc62195a77923e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#a39197b7111b245ab8dc62195a77923e7">increment_num_der1_evaluations</a> ()</td></tr>
<tr class="memdesc:a39197b7111b245ab8dc62195a77923e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments (by 1) gradient evaluation counter.  <a href="#a39197b7111b245ab8dc62195a77923e7">More...</a><br /></td></tr>
<tr class="separator:a39197b7111b245ab8dc62195a77923e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0fd2ad55dbc3c6411234a8fe13b3d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#aaa0fd2ad55dbc3c6411234a8fe13b3d5">set_num_cost_evaluations</a> (int count)</td></tr>
<tr class="memdesc:aaa0fd2ad55dbc3c6411234a8fe13b3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cost evaluation counter to a desired value.  <a href="#aaa0fd2ad55dbc3c6411234a8fe13b3d5">More...</a><br /></td></tr>
<tr class="separator:aaa0fd2ad55dbc3c6411234a8fe13b3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f11dfb69f6af74af31c03c64c7c9a09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03534.html#a6f11dfb69f6af74af31c03c64c7c9a09">set_num_der1_evaluations</a> (int count)</td></tr>
<tr class="memdesc:a6f11dfb69f6af74af31c03c64c7c9a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gradient evaluation counter to a desired value.  <a href="#a6f11dfb69f6af74af31c03c64c7c9a09">More...</a><br /></td></tr>
<tr class="separator:a6f11dfb69f6af74af31c03c64c7c9a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa5c00429c510b3d544fd6db5f7560475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16">message_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03530.html#aa5c00429c510b3d544fd6db5f7560475">mssg</a></td></tr>
<tr class="separator:aa5c00429c510b3d544fd6db5f7560475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198f26a6c80423fe10d527242ba421f"><td class="memItemLeft" align="right" valign="top">blitz::Array&lt; double, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03686.html#a2198f26a6c80423fe10d527242ba421f">X</a></td></tr>
<tr class="separator:a2198f26a6c80423fe10d527242ba421f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for the Non-Linear Least Squares problem. </p>
<p>The class <a class="el" href="a03634.html" title="The base class for the Non-Linear Least Squares problem. ">NLLSProblem</a> is the base class for all problem classes that implement a Non-Linear Least Squares (NLLS) problem. The two main interface components provided by this class are</p><ul>
<li>the residual of the problem (a vector function)</li>
<li>the Jacobian of the residual (the first order derivatives and a matrix function)</li>
</ul>
<p>A NLLS problem can be solved by NLLS solvers such as the Gauss-Newton or the Levenberg-Marquardt methods.</p>
<p><a class="el" href="a03634.html" title="The base class for the Non-Linear Least Squares problem. ">NLLSProblem</a> implements cost and gradient from its inherited classes; therefore, an NLLS problem can also be solved by methods that solve optimization problems of <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> or <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> form.</p>
<p>A DESIGN RELATED QUESTION:</p>
<p>Similar to <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> and <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a>, why don't we have a class that only adds the residual to the class interface and then derive this class from that one to add the Jacobian to the interface as well?</p>
<p>ANSWER TO THE ABOVE QUESTION:</p>
<p>As mentioned in the comments of <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a>, <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> and <a class="el" href="a03634.html" title="The base class for the Non-Linear Least Squares problem. ">NLLSProblem</a> (this) classes, the problems of the forms</p><ul>
<li>cost only (<a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a>)</li>
<li>cost and gradient (<a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a>)</li>
<li>residual and Jacobian (<a class="el" href="a03634.html" title="The base class for the Non-Linear Least Squares problem. ">NLLSProblem</a>)</li>
</ul>
<p>can be solved by certain algorithms. However, there is no method for solving a problem of the form</p><ul>
<li>residual only</li>
</ul>
<p>If the first order derivatives (the Jacobian) of the residual are not available, then the problem can be solved only by the methods that solve a problem of cost-only (<a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a>) form after converting the residual vector function into a cost scalar function using the equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ c(x) = \frac{1}{2}\parallel f(x) \parallel^2 \]" src="form_34.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00054">54</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a944f714d9dae40883d7783dec09b4b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944f714d9dae40883d7783dec09b4b16">&#9670;&nbsp;</a></span>message_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16">FullPhysics::CostFunc::message_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum type for the message generated by the problem. </p>
<p>In general it is very difficult (probably not possible) to develop a general purpose stopping criterion for a general purpose optimization or curve fitting iterative algorithm. The stopping criterion could be very problem dependent. This enumerated type is used to send a message to the solver of a problem, and the iterative solver can optionally take the message into account in deciding how to proceed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a944f714d9dae40883d7783dec09b4b16a80496e9b6583c77605699a042ecdc456"></a>NONE&#160;</td><td class="fielddoc"><p>There are no messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="a944f714d9dae40883d7783dec09b4b16a63f660718f812ce207a64a8c28706dd6"></a>SOLVED&#160;</td><td class="fielddoc"><p>The problem is solved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a944f714d9dae40883d7783dec09b4b16a09ab40e78a0d87e3ab77dd9d04a16603"></a>ERROR&#160;</td><td class="fielddoc"><p>There is an error in the problem. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00038">38</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad8570597ca3e0c48d2736f60d90d53e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8570597ca3e0c48d2736f60d90d53e6">&#9670;&nbsp;</a></span>NLLSProblem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FullPhysics::NLLSProblem::NLLSProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00064">64</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="ae71b502f0a0d38915c8933770c185b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71b502f0a0d38915c8933770c185b4e">&#9670;&nbsp;</a></span>~NLLSProblem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FullPhysics::NLLSProblem::~NLLSProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00069">69</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d88c6f0c515fc412531a3cd7d5f6c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d88c6f0c515fc412531a3cd7d5f6c13">&#9670;&nbsp;</a></span>assert_parameter_correct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProblemState::assert_parameter_correct </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the new input parameters are correct. </p>
<p>This method checks to see whether or not the new input parameters are correct. If the parameters are not correct then it throws an exception. </p>

<p class="definition">Definition at line <a class="el" href="a01109_source.html#l00044">44</a> of file <a class="el" href="a01109_source.html">problem_state.cc</a>.</p>

</div>
</div>
<a id="a8a74617bd73494e1713468a70b0cd0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a74617bd73494e1713468a70b0cd0a8">&#9670;&nbsp;</a></span>assert_parameter_set_correctly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::ProblemState::assert_parameter_set_correctly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the parameters are set correctly. </p>
<p>This method checks to see whether or not the parameters are set correctly. If the parameters are not set correctly then it throws an exception. </p>

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00197">197</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<a id="a82a34d7aec9c7fdf5975c193a0ea5b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a34d7aec9c7fdf5975c193a0ea5b24">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::ProblemState::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes data contents. </p>
<p>This method deletes state. It must be reimplemented by other classes derived from this class to delete other saved components associated with the state as well. </p>

<p>Reimplemented in <a class="el" href="a03638.html#a204e8e57777a3b2bff1bdd1d97e63142">FullPhysics::NLLSProblemState</a>, <a class="el" href="a03630.html#a0d16c1f5624cd1ec0eb41c0e497bc318">FullPhysics::ModelState</a>, <a class="el" href="a03538.html#a81f4ede92356cbcdd4bd16579387daef">FullPhysics::CostFuncDiffState</a>, and <a class="el" href="a03542.html#ac953048e6cf38213562a61b27de99790">FullPhysics::CostFuncState</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00100">100</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<a id="a62f92a8a1f649b2a72237bc8514d1208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f92a8a1f649b2a72237bc8514d1208">&#9670;&nbsp;</a></span>cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double NLLSProblem::cost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read comments on <a class="el" href="a03530.html#a59b277278849ad14484394188379c2bd" title="The cost function. ">CostFunc::cost()</a> </p>

<p>Implements <a class="el" href="a03530.html#a59b277278849ad14484394188379c2bd">FullPhysics::CostFunc</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01061_source.html#l00024">24</a> of file <a class="el" href="a01061_source.html">nlls_problem.cc</a>.</p>

</div>
</div>
<a id="ab3fdea8919e6f537f6df3f8d0319cfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fdea8919e6f537f6df3f8d0319cfbd">&#9670;&nbsp;</a></span>cost_gradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CostFuncDiff::cost_gradient </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cost function and its gradient together. </p>
<p>This method passes to the caller the evaluated cost function and its gradient at the current set point.</p>
<p>The parameters (the point in the parameter space) must have already been set before calling this method. The parameters are already set if one of the following methods is already called successfully:</p><ul>
<li><a class="el" href="a03686.html#aef5427cd26e12e24d4b69778243363e8" title="Sets the problem at a new point in the parameter space. ">parameters()</a> (see <a class="el" href="a03686.html" title="The base class for all problem states. ">ProblemState</a> class)</li>
<li><a class="el" href="a03530.html#a24c0c2f1c7b79f770d9a9348c56a29c6" title="The cost function with parameters. ">cost_x()</a> (see <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> class)</li>
<li><a class="el" href="a03534.html#a916f7963b036e3a3113bc0d8e412b2e0" title="The gradient function with parameters. ">gradient_x()</a></li>
<li><a class="el" href="a03534.html#ab978fff25f8b7707dc76cf8338306cb9" title="The cost function and its gradient with parameters. ">cost_gradient_x()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The cost function value</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The gradient vector with size <a class="el" href="a03534.html#a65e3ba335fe38770e1a00841167466fc" title="Returns the size of the gradient vector. ">gradient_size()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00911_source.html#l00017">17</a> of file <a class="el" href="a00911_source.html">cost_func_diff.cc</a>.</p>

</div>
</div>
<a id="ab978fff25f8b7707dc76cf8338306cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab978fff25f8b7707dc76cf8338306cb9">&#9670;&nbsp;</a></span>cost_gradient_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::CostFuncDiff::cost_gradient_x </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cost function and its gradient with parameters. </p>
<p>This method passes to the caller the evaluated cost function and its gradient after setting the problem at the input new point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The cost function value</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>The gradient vector with size <a class="el" href="a03534.html#a65e3ba335fe38770e1a00841167466fc" title="Returns the size of the gradient vector. ">gradient_size()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00128">128</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<a id="a24c0c2f1c7b79f770d9a9348c56a29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c0c2f1c7b79f770d9a9348c56a29c6">&#9670;&nbsp;</a></span>cost_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double FullPhysics::CostFunc::cost_x </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cost function with parameters. </p>
<p>This method also evaluates the cost function; however, it sets the problem at the input new point and then evaluates the cost function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cost function value </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00089">89</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<a id="adc11f14bee4751e1a2c34ecaa70894af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc11f14bee4751e1a2c34ecaa70894af">&#9670;&nbsp;</a></span>expected_parameter_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::ProblemState::expected_parameter_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the expected size of the parameters. </p>
<p>This method must be reimplemented by the problem class the inherits <a class="el" href="a03686.html" title="The base class for all problem states. ">ProblemState</a>. It is only in the context of an optimization problem that one knows what the size of the parameters (number of the dimensions of the parameter space) is.</p>
<p>This method is intentionally implemented here instead of being left as a pure virtual method. The intention is that the user to be able to create an object of this class or its derived classes for the purpose of preserving an older state of a problem if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>Expected size of parameters </dd></dl>

<p>Reimplemented in <a class="el" href="a03258.html#ac3778fac32505efd281ef106f6dae289">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#a014a5245f9e6d24b9636ed3e011c7098">FullPhysics::NLLSMaxLikelihood</a>, <a class="el" href="a03266.html#ab06556d7bbcf2e9daf073422416a9fa1">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a03254.html#a3979f93676e8bea1ccaeaaa331da26c3">FullPhysics::ModelMeasureStandard</a>, <a class="el" href="a03246.html#abd70818ea3f6f0cf257029e3833d5723">FullPhysics::ModelMeasureBard</a>, <a class="el" href="a03250.html#a30d9ab1292a50ed27d5a0d1df44c03ef">FullPhysics::ModelMeasureMeyer</a>, <a class="el" href="a02670.html#adfd7e6baaa70e9e12a67ecf35473468c">FullPhysics::FmNLLSProblem</a>, <a class="el" href="a02566.html#ade68326731ca97313ed1db9fb0047da5">FullPhysics::BardNLLSProblem</a>, <a class="el" href="a02570.html#a1ee3ccfbf0d44d92bfa0c267910ee600">FullPhysics::BrownNLLSProblem</a>, <a class="el" href="a02678.html#a9d54f243ad1c932e0cdb084efc110d74">FullPhysics::FreudensteinRothNLLSProblem</a>, <a class="el" href="a02718.html#a68bf9354a027284d1fc77c83461b09f8">FullPhysics::HelicalValleyNLLSProblem</a>, <a class="el" href="a02746.html#a4a6c2db5166b75de881f52ff0d523fd2">FullPhysics::JennrichSampsonNLLSProblem</a>, <a class="el" href="a03242.html#a378c9b0589e6dec36d72f9435546966f">FullPhysics::MeyerNLLSProblem</a>, <a class="el" href="a03310.html#a9783389380ffe956f748b7941b04a520">FullPhysics::PowellNLLSProblem</a>, <a class="el" href="a03314.html#ab49fb1a80e75aa6c72aebe06aa5b4151">FullPhysics::PowellSingularNLLSProblem</a>, and <a class="el" href="a03362.html#ac94c988aeb9d61dfc1b0e2b796704490">FullPhysics::Rosenbrock2NLLSProblem</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00185">185</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<a id="a89d68693bbbe2ee31fb93fde8638c0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d68693bbbe2ee31fb93fde8638c0c6">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">blitz::Array&lt; double, 1 &gt; NLLSProblem::gradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read comments on <a class="el" href="a03534.html#a76dd357c7aa315487b5a7d52000b481e" title="The gradient of the cost function. ">CostFuncDiff::gradient()</a> </p>

<p>Implements <a class="el" href="a03534.html#a76dd357c7aa315487b5a7d52000b481e">FullPhysics::CostFuncDiff</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01061_source.html#l00029">29</a> of file <a class="el" href="a01061_source.html">nlls_problem.cc</a>.</p>

</div>
</div>
<a id="a65e3ba335fe38770e1a00841167466fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e3ba335fe38770e1a00841167466fc">&#9670;&nbsp;</a></span>gradient_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::CostFuncDiff::gradient_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the gradient vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the gradient vecotor </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00157">157</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<a id="a916f7963b036e3a3113bc0d8e412b2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916f7963b036e3a3113bc0d8e412b2e0">&#9670;&nbsp;</a></span>gradient_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blitz::Array&lt;double, 1&gt; FullPhysics::CostFuncDiff::gradient_x </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The gradient function with parameters. </p>
<p>This method also evaluates the gradient of the cost function; however, it sets the problem at the input new point and then evaluates the gradient.</p>
<p>The size of the gradient vector can be obtained in advance by calling <a class="el" href="a03534.html#a65e3ba335fe38770e1a00841167466fc" title="Returns the size of the gradient vector. ">gradient_size()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient of the cost function </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00082">82</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<a id="ac40e427ca8e29afb50489ac25d31f6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40e427ca8e29afb50489ac25d31f6a3">&#9670;&nbsp;</a></span>increment_num_cost_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::CostFunc::increment_num_cost_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments (by 1) cost evaluation counter. </p>
<p>The developer of a derived class, where the true cost function evaluation is implemented, must also call this method when the cost function is evaluated.</p>
<p>It is possible to call this method in <a class="el" href="a03530.html#a24c0c2f1c7b79f770d9a9348c56a29c6" title="The cost function with parameters. ">cost_x()</a> method; however, at this level we do not know when the cost function gets truly evaluated.</p>
<p>The developer of a derived class can save the expensive components of a cost function evaluation and reuse them when cost is inquired and the parameters have not changed. Therefore, she has the options of calling <a class="el" href="a03530.html#ac40e427ca8e29afb50489ac25d31f6a3" title="Increments (by 1) cost evaluation counter. ">increment_num_cost_evaluations()</a></p><ol type="1">
<li>any time cost is inquired or</li>
<li>only when cost is truly evaluated.</li>
</ol>
<p>If X1 and X2 are two different sets of parameters, then after the sequence of method calls</p><ul>
<li>cost_x(X1)</li>
<li>cost_x(X1)</li>
<li>cost_x(X2)</li>
<li>cost_x(X2)</li>
</ul>
<p>with the first design option mentioned above <a class="el" href="a03530.html#a8bf7aaf54949298bd97d395ebe91faa2" title="Returns the number of the times cost has been evaluated. ">num_cost_evaluations()</a> will return 4, but with the second option mentioned above <a class="el" href="a03530.html#a8bf7aaf54949298bd97d395ebe91faa2" title="Returns the number of the times cost has been evaluated. ">num_cost_evaluations()</a> will return 2.</p>
<p>Therefore, in my opinion it was best not to decide when to call this method at this level in <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> class. </p>

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00198">198</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<a id="a39197b7111b245ab8dc62195a77923e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39197b7111b245ab8dc62195a77923e7">&#9670;&nbsp;</a></span>increment_num_der1_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::CostFuncDiff::increment_num_der1_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments (by 1) gradient evaluation counter. </p>
<p>The developer of a derived class, where the true gradient evaluation is implemented, must also call this method when the gradient (first order derivatives) is evaluated.</p>
<p>It is possible to call this method in <a class="el" href="a03534.html#a916f7963b036e3a3113bc0d8e412b2e0" title="The gradient function with parameters. ">gradient_x()</a> method; however, at this level we do not know when the gradient gets truly evaluated.</p>
<p>The developer of a derived class can save the expensive components of the gradient evaluation and reuse them when gradient is inquired and the parameters have not changed. Therefore, she has the options of calling <a class="el" href="a03534.html#a39197b7111b245ab8dc62195a77923e7" title="Increments (by 1) gradient evaluation counter. ">increment_num_der1_evaluations()</a></p><ol type="1">
<li>any time gradient is inquired or</li>
<li>only when gradient is truly evaluated.</li>
</ol>
<p>If X1 and X2 are two different sets of parameters, then after the sequence of method calls</p><ul>
<li>gradient_x(X1)</li>
<li>gradient_x(X1)</li>
<li>gradient_x(X2)</li>
<li>gradient_x(X2)</li>
</ul>
<p>with the first design option mentioned above <a class="el" href="a03534.html#aa394e8c65adbaa539df24ff867992abd" title="Returns the number of the times gradient has been evaluated. ">num_der1_evaluations()</a> will return 4, but with the second option mentioned above <a class="el" href="a03534.html#aa394e8c65adbaa539df24ff867992abd" title="Returns the number of the times gradient has been evaluated. ">num_der1_evaluations()</a> will return 2.</p>
<p>Therefore, in my opinion it was best not to decide when to call this method at this level in <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> class. </p>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00205">205</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<a id="ac3aea615310738b4878e046d70a41881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aea615310738b4878e046d70a41881">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blitz::Array&lt;double, 2&gt; FullPhysics::NLLSProblem::jacobian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Jacobian matrix function. </p>
<p>This method must be implemented by the classes derived from this class.</p>
<p>The parameters (the point in the parameter space) must have already been set before calling this method. The parameters are already set if one of the following methods is already called successfully:</p><ul>
<li><a class="el" href="a03686.html#aef5427cd26e12e24d4b69778243363e8" title="Sets the problem at a new point in the parameter space. ">parameters()</a> (see <a class="el" href="a03686.html" title="The base class for all problem states. ">ProblemState</a> class)</li>
<li><a class="el" href="a03530.html#a24c0c2f1c7b79f770d9a9348c56a29c6" title="The cost function with parameters. ">cost_x()</a> (see <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> class)</li>
<li><a class="el" href="a03534.html#a916f7963b036e3a3113bc0d8e412b2e0" title="The gradient function with parameters. ">gradient_x()</a> (see <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> class)</li>
<li><a class="el" href="a03534.html#ab978fff25f8b7707dc76cf8338306cb9" title="The cost function and its gradient with parameters. ">cost_gradient_x()</a> (see <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> class)</li>
<li><a class="el" href="a03634.html#ab4dc6f23d523caf9573f5e72bd377c85" title="The residual function with parameters. ">residual_x()</a></li>
<li><a class="el" href="a03634.html#af6ed15ffb9ed8263ba145423a060aa09" title="The Jacobian function with parameters. ">jacobian_x()</a></li>
<li><a class="el" href="a03634.html#af197676bde1e1f65756d2649177ee1f2" title="The residual and its Jacobian with parameters. ">residual_jacobian_x()</a></li>
</ul>
<p>If the parameters are already set, then this method returns the Jacobian of the residual of the NLLS problem at the current set point.</p>
<p>The sizes of the Jacobian matrix can be obtained in advance:</p><ul>
<li>The number of its rows is the same as <a class="el" href="a03634.html#a07ef1fc7d9345085e7898dc6f5277fbb" title="The size of the residual returned by residual() ">residual_size()</a>.</li>
<li>The number of its columns is the same as <a class="el" href="a03686.html#adc11f14bee4751e1a2c34ecaa70894af" title="Returns the expected size of the parameters. ">ProblemState::expected_parameter_size()</a> or <a class="el" href="a03534.html#a65e3ba335fe38770e1a00841167466fc" title="Returns the size of the gradient vector. ">CostFuncDiff::gradient_size()</a></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The Jacobian of the residual of the NLLS problem </dd></dl>

<p>Implemented in <a class="el" href="a03258.html#ab0d5ceb05189d557e3df6ea44b9780e3">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#a3cda1a8976067564aea87631a90942d2">FullPhysics::NLLSMaxLikelihood</a>, <a class="el" href="a03266.html#add37b7b4bcdfbc6a42b49653b8b5977b">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a02670.html#abbb460e26a3e43ccde1854b230b68960">FullPhysics::FmNLLSProblem</a>, <a class="el" href="a02566.html#a86390700252c4149f3760517a518ab84">FullPhysics::BardNLLSProblem</a>, <a class="el" href="a02570.html#a3b7bc5e075f79e91b016b3f57e5fde64">FullPhysics::BrownNLLSProblem</a>, <a class="el" href="a02678.html#a359691f5d702f2b124939a64d92839a4">FullPhysics::FreudensteinRothNLLSProblem</a>, <a class="el" href="a02718.html#adf4fa260ebc2626f22cdb1460f9f72cf">FullPhysics::HelicalValleyNLLSProblem</a>, <a class="el" href="a02746.html#ad25c12fbbf773734301e1fc9fee93ccf">FullPhysics::JennrichSampsonNLLSProblem</a>, <a class="el" href="a03242.html#ad7900f1c2c593cf8a3048198f8bafea5">FullPhysics::MeyerNLLSProblem</a>, <a class="el" href="a03310.html#a6c0f3c7ac6cbd30cd8aa7dd8479ea70e">FullPhysics::PowellNLLSProblem</a>, <a class="el" href="a03314.html#a52b79de868d8ba056ad7756962c04036">FullPhysics::PowellSingularNLLSProblem</a>, and <a class="el" href="a03362.html#a59f62b06028988975a2354a13ef106d6">FullPhysics::Rosenbrock2NLLSProblem</a>.</p>

</div>
</div>
<a id="af6ed15ffb9ed8263ba145423a060aa09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ed15ffb9ed8263ba145423a060aa09">&#9670;&nbsp;</a></span>jacobian_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blitz::Array&lt;double, 2&gt; FullPhysics::NLLSProblem::jacobian_x </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Jacobian function with parameters. </p>
<p>This method also evaluates the Jacobian of the residual of the NLLS problem; however, it sets the problem at the input new point and then evaluates the Jacobian.</p>
<p>The sizes of the Jacobian matrix can be obtained in advance as mentioned in the comments on <a class="el" href="a03634.html#ac3aea615310738b4878e046d70a41881" title="The Jacobian matrix function. ">jacobian()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Jacobian of the residual of the NLLS problem </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00186">186</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="a36ee6a711398e496f227e73e16661717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ee6a711398e496f227e73e16661717">&#9670;&nbsp;</a></span>message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16">message_t</a> FullPhysics::CostFunc::message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value of <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16" title="Enum type for the message generated by the problem. ">CostFunc::message_t</a> type. </p>
<p>This method returns a problem generated message. The message is initialized as <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a80496e9b6583c77605699a042ecdc456" title="There are no messages. ">CostFunc::NONE</a>. The implementation of a problem can optionally set it to other values as needed, and the solver of the problem can optionally take different course of actions for different messages.</p>
<p>It is assumed that the solver will not take any different course of action if the returned value is <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a80496e9b6583c77605699a042ecdc456" title="There are no messages. ">CostFunc::NONE</a>. For other possible values check the comments on <a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16" title="Enum type for the message generated by the problem. ">CostFunc::message_t</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>problem message </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00127">127</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<a id="a8cabd454ac6952b51d179c1465cc45ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cabd454ac6952b51d179c1465cc45ac">&#9670;&nbsp;</a></span>message_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char *const CostFunc::message_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string version of the problem message. </p>
<p>If the method status() returns</p><ul>
<li><a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a80496e9b6583c77605699a042ecdc456" title="There are no messages. ">CostFunc::NONE</a></li>
<li><a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a63f660718f812ce207a64a8c28706dd6" title="The problem is solved. ">CostFunc::SOLVED</a></li>
<li><a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16a09ab40e78a0d87e3ab77dd9d04a16603" title="There is an error in the problem. ">CostFunc::ERROR</a></li>
</ul>
<p>then <a class="el" href="a03530.html#a8cabd454ac6952b51d179c1465cc45ac" title="Returns the string version of the problem message. ">message_str()</a> will return</p><ul>
<li>"NONE"</li>
<li>"SOLVED"</li>
<li>"ERROR"</li>
</ul>
<p>respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>problem message in string form </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00905_source.html#l00014">14</a> of file <a class="el" href="a00905_source.html">cost_func.cc</a>.</p>

</div>
</div>
<a id="a8bf7aaf54949298bd97d395ebe91faa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf7aaf54949298bd97d395ebe91faa2">&#9670;&nbsp;</a></span>num_cost_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::CostFunc::num_cost_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the times cost has been evaluated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of the times cost has been evaluated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00099">99</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<a id="aa394e8c65adbaa539df24ff867992abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa394e8c65adbaa539df24ff867992abd">&#9670;&nbsp;</a></span>num_der1_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::CostFuncDiff::num_der1_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the times gradient has been evaluated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of the times gradient has been evaluated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00139">139</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<a id="a0fd672c7a966b6f6797ad9b5c00c3080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd672c7a966b6f6797ad9b5c00c3080">&#9670;&nbsp;</a></span>num_jacobian_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::NLLSProblem::num_jacobian_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the times Jacobian has been evaluated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of the times Jacobian has been evaluated </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00256">256</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="aa23e1926e49bb96d4f9cd23a4f0d35b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23e1926e49bb96d4f9cd23a4f0d35b4">&#9670;&nbsp;</a></span>num_residual_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::NLLSProblem::num_residual_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the times residual has been evaluated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of the times residual has been evaluated </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00246">246</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="afb80491a2ba69cb450ddc122730d96f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb80491a2ba69cb450ddc122730d96f2">&#9670;&nbsp;</a></span>parameter_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::ProblemState::parameter_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of parameters </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00163">163</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<a id="aef5427cd26e12e24d4b69778243363e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5427cd26e12e24d4b69778243363e8">&#9670;&nbsp;</a></span>parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProblemState::parameters </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the problem at a new point in the parameter space. </p>
<p>The method calls <a class="el" href="a03686.html#ab13a0649637d0510602e9eb0abffca9a" title="Checks whether or not new input parameters are different from the current ones. ">parameters_different()</a> to determine whether or not the new parameters are different:</p><ul>
<li>If different, then it deletes the object state (see <a class="el" href="a03686.html#a82a34d7aec9c7fdf5975c193a0ea5b24" title="Deletes data contents. ">clear()</a>), and the input x becomes the current state.</li>
<li>If not different, then the input parameters are ignored.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="a03266.html#afcbc7224edcc26ea0dbc79a8e7b58efb">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a03258.html#aacd2a2facbde51f727acc92d2ccc9b16">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#ab24b9bcee20ba5761977cbada6619499">FullPhysics::NLLSMaxLikelihood</a>, and <a class="el" href="a03254.html#a14f113283cd83054459b169a6002c7cd">FullPhysics::ModelMeasureStandard</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01109_source.html#l00036">36</a> of file <a class="el" href="a01109_source.html">problem_state.cc</a>.</p>

</div>
</div>
<a id="ac6eb5f3b2856a3be0d0ce5416063c83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eb5f3b2856a3be0d0ce5416063c83b">&#9670;&nbsp;</a></span>parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blitz::Array&lt;double, 1&gt; FullPhysics::ProblemState::parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>Current parameter </dd></dl>

<p>Reimplemented in <a class="el" href="a03266.html#aa3cd24f008b168923501a8fbf43990d6">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a03258.html#a13c87526673a00a9227f9a7c44b62f4c">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#aabdda6e968de7013085b07ff6a7bd40d">FullPhysics::NLLSMaxLikelihood</a>, and <a class="el" href="a03254.html#a4e8262878bbcd896b58063b82a421718">FullPhysics::ModelMeasureStandard</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00153">153</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<a id="ab13a0649637d0510602e9eb0abffca9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13a0649637d0510602e9eb0abffca9a">&#9670;&nbsp;</a></span>parameters_different()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProblemState::parameters_different </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether or not new input parameters are different from the current ones. </p>
<p>The methods checks to see whether or not the new input parameters (point in the parameter space) are different from the parameters maintained by the object for which the method is called.</p>
<p>If the size of the input parameters is not equal to the expected size of the parameters (check comments on expected_parameter_size), then the method will throw an exception.</p>
<p>If the object for which the method is called has currently no parameters set, then the method returns true. Otherwise, the method uses some algorithm to figure out when the difference is "big enough" to be considered different. If the method determines that the new input parameters are different from the current parameters, then it returns true, otherwise, it returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a01109_source.html#l00009">9</a> of file <a class="el" href="a01109_source.html">problem_state.cc</a>.</p>

</div>
</div>
<a id="a8ecc6162b90ea155dffe1250d6413afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecc6162b90ea155dffe1250d6413afb">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::NLLSProblem::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>Os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints description of object. </p>

<p>Reimplemented from <a class="el" href="a03534.html#a19df753ec787a954ad3cdabfa23964c6">FullPhysics::CostFuncDiff</a>.</p>

<p>Reimplemented in <a class="el" href="a03266.html#a62d87c6003261e7aab7af2080c529fd6">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a03258.html#a96b0f0dd37f207bea90c445085e5802d">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#aef2705f296dacf0768498eb503a90c45">FullPhysics::NLLSMaxLikelihood</a>, <a class="el" href="a02670.html#a31c4c54c410d92a0ff89b71a2aa494af">FullPhysics::FmNLLSProblem</a>, <a class="el" href="a02566.html#ab0d03d4f466c87a9325a98be050dea0d">FullPhysics::BardNLLSProblem</a>, <a class="el" href="a02570.html#a9b295946ccac36e29b36b798a0274fc8">FullPhysics::BrownNLLSProblem</a>, <a class="el" href="a02678.html#a3260ca86216e9e660eaae487ed18cb3f">FullPhysics::FreudensteinRothNLLSProblem</a>, <a class="el" href="a02718.html#afd7e47c07917269833fed044a8b603e0">FullPhysics::HelicalValleyNLLSProblem</a>, <a class="el" href="a02746.html#a03350b0aa9ab7cbd85377c4fec2866d3">FullPhysics::JennrichSampsonNLLSProblem</a>, <a class="el" href="a03242.html#a6ba6da38935db9480b8d2e5b02e1ed3e">FullPhysics::MeyerNLLSProblem</a>, <a class="el" href="a03310.html#a5e192c14c2ede103fd98b5f33d276067">FullPhysics::PowellNLLSProblem</a>, <a class="el" href="a03314.html#aa934789a3a809a5878a7a447eaaf058a">FullPhysics::PowellSingularNLLSProblem</a>, and <a class="el" href="a03362.html#a02041366207d02e389f647a0b658aeaf">FullPhysics::Rosenbrock2NLLSProblem</a>.</p>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00276">276</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="aaa21f558fa22a1f06175a1357c7f5a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa21f558fa22a1f06175a1357c7f5a22">&#9670;&nbsp;</a></span>print_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="a04618.html">FullPhysics::Printable</a>&lt; <a class="el" href="a03686.html">ProblemState</a>  &gt;::print_to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print to string. </p>
<p>This is primarily useful for SWIG wrappers to this class, e.g. a to_s method in ruby. </p>

<p class="definition">Definition at line <a class="el" href="a01742_source.html#l00031">31</a> of file <a class="el" href="a01742_source.html">printable.h</a>.</p>

</div>
</div>
<a id="a34e584291e1337af17fcf9b22792ccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e584291e1337af17fcf9b22792ccc6">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blitz::Array&lt;double, 1&gt; FullPhysics::NLLSProblem::residual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The residual vector function. </p>
<p>This method must be implemented by the classes derived from this class.</p>
<p>The parameters (the point in the parameter space) must have already been set before calling this method. The parameters are already set if one of the following methods is already called successfully:</p><ul>
<li><a class="el" href="a03686.html#aef5427cd26e12e24d4b69778243363e8" title="Sets the problem at a new point in the parameter space. ">parameters()</a> (see <a class="el" href="a03686.html" title="The base class for all problem states. ">ProblemState</a> class)</li>
<li><a class="el" href="a03530.html#a24c0c2f1c7b79f770d9a9348c56a29c6" title="The cost function with parameters. ">cost_x()</a> (see <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> class)</li>
<li><a class="el" href="a03534.html#a916f7963b036e3a3113bc0d8e412b2e0" title="The gradient function with parameters. ">gradient_x()</a> (see <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> class)</li>
<li><a class="el" href="a03534.html#ab978fff25f8b7707dc76cf8338306cb9" title="The cost function and its gradient with parameters. ">cost_gradient_x()</a> (see <a class="el" href="a03534.html" title="The base class for all problem classes that implement a cost function and its gradient. ">CostFuncDiff</a> class)</li>
<li><a class="el" href="a03634.html#ab4dc6f23d523caf9573f5e72bd377c85" title="The residual function with parameters. ">residual_x()</a></li>
<li><a class="el" href="a03634.html#af6ed15ffb9ed8263ba145423a060aa09" title="The Jacobian function with parameters. ">jacobian_x()</a></li>
<li><a class="el" href="a03634.html#af197676bde1e1f65756d2649177ee1f2" title="The residual and its Jacobian with parameters. ">residual_jacobian_x()</a></li>
</ul>
<p>If the parameters are already set, then this method returns the residual of the NLLS problem at the current set point.</p>
<p>The size of the residual vector can be obtained in advance by calling <a class="el" href="a03634.html#a07ef1fc7d9345085e7898dc6f5277fbb" title="The size of the residual returned by residual() ">residual_size()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The residual of the NLLS problem </dd></dl>

<p>Implemented in <a class="el" href="a03258.html#ae59d1ccfdf1616000ffcfedebc8348bb">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#aee949b16bc7eefb358d62b88dd40be10">FullPhysics::NLLSMaxLikelihood</a>, <a class="el" href="a03266.html#a818d4ee687d088d7e7b5d34433f9759c">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a02670.html#a47261fb5caea19be5980e8aeac7d60f3">FullPhysics::FmNLLSProblem</a>, <a class="el" href="a02566.html#a29ebb12412b2eca7dc61236a1aafcdbe">FullPhysics::BardNLLSProblem</a>, <a class="el" href="a02570.html#a1e2275e162e12cbf4c702f8e47cf6849">FullPhysics::BrownNLLSProblem</a>, <a class="el" href="a02678.html#a1e42288feb930c237cdd3b192b827c5c">FullPhysics::FreudensteinRothNLLSProblem</a>, <a class="el" href="a02718.html#a91b6bf0026a552b4efde0d2c62932498">FullPhysics::HelicalValleyNLLSProblem</a>, <a class="el" href="a02746.html#a642582fd7d1afb2d8eaf2fbea130cde1">FullPhysics::JennrichSampsonNLLSProblem</a>, <a class="el" href="a03242.html#ad86de3d80d449077cf1013de9dbfeb3b">FullPhysics::MeyerNLLSProblem</a>, <a class="el" href="a03310.html#a6952936183ae3ab81e94675218ce5fe5">FullPhysics::PowellNLLSProblem</a>, <a class="el" href="a03314.html#a8038e1efe3da8c588cd83a44b6e0e956">FullPhysics::PowellSingularNLLSProblem</a>, and <a class="el" href="a03362.html#a5c14ee15783827e14ff0219f6d1b306c">FullPhysics::Rosenbrock2NLLSProblem</a>.</p>

</div>
</div>
<a id="ad32ac2df20983d61228eeae47380e6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32ac2df20983d61228eeae47380e6e6">&#9670;&nbsp;</a></span>residual_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NLLSProblem::residual_jacobian </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The residual function and its Jacobian together. </p>
<p>This method passes to the caller the evaluated residual function and its Jacobian at the current set point.</p>
<p>The parameters (the point in the parameter space) must have already been set before calling this method. The parameters are already set if one of the following methods is already called successfully:</p><ul>
<li><a class="el" href="a03686.html#aef5427cd26e12e24d4b69778243363e8" title="Sets the problem at a new point in the parameter space. ">parameters()</a> (see <a class="el" href="a03686.html" title="The base class for all problem states. ">ProblemState</a> class)</li>
<li><a class="el" href="a03530.html#a24c0c2f1c7b79f770d9a9348c56a29c6" title="The cost function with parameters. ">cost_x()</a> (see <a class="el" href="a03530.html" title="The base class for all problem classes that implement a cost function. ">CostFunc</a> class)</li>
<li><a class="el" href="a03534.html#a916f7963b036e3a3113bc0d8e412b2e0" title="The gradient function with parameters. ">gradient_x()</a></li>
<li><a class="el" href="a03534.html#ab978fff25f8b7707dc76cf8338306cb9" title="The cost function and its gradient with parameters. ">cost_gradient_x()</a></li>
<li><a class="el" href="a03634.html#ab4dc6f23d523caf9573f5e72bd377c85" title="The residual function with parameters. ">residual_x()</a></li>
<li><a class="el" href="a03634.html#af6ed15ffb9ed8263ba145423a060aa09" title="The Jacobian function with parameters. ">jacobian_x()</a></li>
<li><a class="el" href="a03634.html#af197676bde1e1f65756d2649177ee1f2" title="The residual and its Jacobian with parameters. ">residual_jacobian_x()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>The residual vector</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">j</td><td>The Jacobian matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a01061_source.html#l00018">18</a> of file <a class="el" href="a01061_source.html">nlls_problem.cc</a>.</p>

</div>
</div>
<a id="af197676bde1e1f65756d2649177ee1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af197676bde1e1f65756d2649177ee1f2">&#9670;&nbsp;</a></span>residual_jacobian_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::NLLSProblem::residual_jacobian_x </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The residual and its Jacobian with parameters. </p>
<p>This method passes to the caller the evaluated residual function and its Jacobian after setting the problem at the input new point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>The residual vector</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">j</td><td>The Jacobian matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00235">235</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="a07ef1fc7d9345085e7898dc6f5277fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ef1fc7d9345085e7898dc6f5277fbb">&#9670;&nbsp;</a></span>residual_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int FullPhysics::NLLSProblem::residual_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the residual returned by <a class="el" href="a03634.html#a34e584291e1337af17fcf9b22792ccc6" title="The residual vector function. ">residual()</a> </p>
<p>This method must be implemented by the classes derived from this class.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the residual that will be returned by <a class="el" href="a03634.html#a34e584291e1337af17fcf9b22792ccc6" title="The residual vector function. ">residual()</a> </dd></dl>

<p>Implemented in <a class="el" href="a03258.html#a0017e644bbd4d94d8cd2908ed4984eea">FullPhysics::NLLSMaxAPosteriori</a>, <a class="el" href="a03262.html#a69fa395f38e307f54ea4397e27978cd7">FullPhysics::NLLSMaxLikelihood</a>, <a class="el" href="a03266.html#a919fdb820ed3ed9b3ef2a82a3a90eea9">FullPhysics::NLLSProblemScaled</a>, <a class="el" href="a02670.html#a25dd72b9de2f88987bea044e9ee1fd56">FullPhysics::FmNLLSProblem</a>, <a class="el" href="a02566.html#ac32784ab1aff6c83271c6c2144d5d225">FullPhysics::BardNLLSProblem</a>, <a class="el" href="a02570.html#a32600645c08cb7ab4bdba5dd7ab798da">FullPhysics::BrownNLLSProblem</a>, <a class="el" href="a02678.html#aa55a38a6f5636ab3892381d2e9e676d7">FullPhysics::FreudensteinRothNLLSProblem</a>, <a class="el" href="a02718.html#a8e1db65bb6edf8dca845389ce921b5a7">FullPhysics::HelicalValleyNLLSProblem</a>, <a class="el" href="a02746.html#aa74fe027d300671fd7674d40f3876a01">FullPhysics::JennrichSampsonNLLSProblem</a>, <a class="el" href="a03242.html#a4ae60f377df270d31bac20cb20d5b84a">FullPhysics::MeyerNLLSProblem</a>, <a class="el" href="a03310.html#a47423676ea15e026b83687c0c5499090">FullPhysics::PowellNLLSProblem</a>, <a class="el" href="a03314.html#ae853d4eec45dbdb91831be9d0510dca5">FullPhysics::PowellSingularNLLSProblem</a>, and <a class="el" href="a03362.html#a1cfb9b6a21fe10e20c5b8dc92f9f5fab">FullPhysics::Rosenbrock2NLLSProblem</a>.</p>

</div>
</div>
<a id="ab4dc6f23d523caf9573f5e72bd377c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dc6f23d523caf9573f5e72bd377c85">&#9670;&nbsp;</a></span>residual_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blitz::Array&lt;double, 1&gt; FullPhysics::NLLSProblem::residual_x </td>
          <td>(</td>
          <td class="paramtype">const blitz::Array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The residual function with parameters. </p>
<p>This method also evaluates the residual of the NLLS problem; however, it sets the problem at the input new point and then evaluates the residual.</p>
<p>The size of the residual vector can be obtained in advance by calling <a class="el" href="a03634.html#a07ef1fc7d9345085e7898dc6f5277fbb" title="The size of the residual returned by residual() ">residual_size()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>New set of parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The residual of the cost function </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01064_source.html#l00132">132</a> of file <a class="el" href="a01064_source.html">nlls_problem.h</a>.</p>

</div>
</div>
<a id="a344962852814f6b7610aac73b1a61ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344962852814f6b7610aac73b1a61ff4">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::ProblemState::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a03686.html">ProblemState</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes self a copy of the input state. </p>
<p>This method makes the object, for which it is called, a copy of the input state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>another <a class="el" href="a03686.html" title="The base class for all problem states. ">ProblemState</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00088">88</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<a id="aaa0fd2ad55dbc3c6411234a8fe13b3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0fd2ad55dbc3c6411234a8fe13b3d5">&#9670;&nbsp;</a></span>set_num_cost_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::CostFunc::set_num_cost_evaluations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the cost evaluation counter to a desired value. </p>
<p>This method sets the cost evaluation counter to a desired value. It is just provided if the developers of the derived classes have any use for it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Desired value for cost evaluation counter setting </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00213">213</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<a id="a6f11dfb69f6af74af31c03c64c7c9a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f11dfb69f6af74af31c03c64c7c9a09">&#9670;&nbsp;</a></span>set_num_der1_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::CostFuncDiff::set_num_der1_evaluations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gradient evaluation counter to a desired value. </p>
<p>This method sets the gradient (first order derivatives) evaluation counter to a desired value. It is just provided if the developers of the derived classes have any use for it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Desired value for gradient evaluation counter setting </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00220">220</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<a id="ac9bc58ea76aef6b4fd1bdc3212ac6cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bc58ea76aef6b4fd1bdc3212ac6cb7">&#9670;&nbsp;</a></span>zero_num_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FullPhysics::CostFuncDiff::zero_num_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets cost and gradient evaluation counters to zero. </p>

<p>Reimplemented from <a class="el" href="a03530.html#abe6a0eb717b534a5cfa3f7760b9e6a42">FullPhysics::CostFunc</a>.</p>

<p class="definition">Definition at line <a class="el" href="a00914_source.html#l00147">147</a> of file <a class="el" href="a00914_source.html">cost_func_diff.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa5c00429c510b3d544fd6db5f7560475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c00429c510b3d544fd6db5f7560475">&#9670;&nbsp;</a></span>mssg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03530.html#a944f714d9dae40883d7783dec09b4b16">message_t</a> FullPhysics::CostFunc::mssg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00908_source.html#l00163">163</a> of file <a class="el" href="a00908_source.html">cost_func.h</a>.</p>

</div>
</div>
<a id="a2198f26a6c80423fe10d527242ba421f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2198f26a6c80423fe10d527242ba421f">&#9670;&nbsp;</a></span>X</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">blitz::Array&lt;double, 1&gt; FullPhysics::ProblemState::X</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a01112_source.html#l00222">222</a> of file <a class="el" href="a01112_source.html">problem_state.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Interface/<a class="el" href="a01064_source.html">nlls_problem.h</a></li>
<li>Interface/<a class="el" href="a01061_source.html">nlls_problem.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<address style="align: right;"><small>
<center>
Copyright &copy 2017, California Institute of Technology.<br/>
            ALL RIGHTS RESERVED.<br/>
  U.S. Government Sponsorship acknowledged.<br/>
  Generated Fri Aug 24 2018 15:44:13
</center></small></address>
</body>
</html>
